<h2 data-ke-size="size26">문제 상황 - JPA의 FROM절에 subquery를 넣는 상황.</h2>
<p data-ke-size="size16">&nbsp;문제 상황은 다음과 같다.</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">&nbsp;킥보드 사용량에 대한 consumption entity가 있고, 킥보드의 이동 경로에 대한 coordinate entity가 있다. consumption : coordinate는 1 : n 관계이며, coordinate entity에 다대일 매핑만 되어 있다.</p>
<pre id="code_1694010667423" class="java" data-ke-language="java" data-ke-type="codeblock"><code>@Entity
@Getter
@AllArgsConstructor
@Table(name = "consumption")
public class Consumption {
    @Id
    @Column(name = "consumption_id")
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column
    private Integer cost;
}</code></pre>
<pre id="code_1694010677517" class="java" data-ke-language="java" data-ke-type="codeblock"><code>@Entity
@Getter
@AllArgsConstructor
@Table(name = "coordinate")
public class Coordinate {
    @Id
    @Column(name = "coordinate_id")
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false)
    private Long sequence;

    @Column(nullable = false)
    private double longitude;

    @Column(nullable = false)
    private double latitude;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "consumption_id")
    private Consumption consumption;

    public void setRelationWithConsumption(Consumption consumption){
        this.consumption = consumption;
    }
}</code></pre>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">&nbsp;이 상황에서 사용자가 쓴 킥보드 사용량과 이동 경로를 한 번에 불러오고 싶다! 단, 페이징을 해야 한다!</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">&nbsp;다대일 매핑만 사용한 이유는, 일단 일대다 매핑을 최대한 지양하기 위해서이다. 일대다 매핑을 사용하면 foreign key가 다른 table에 있기 때문에 DB의 패러다임과 달라지는 문제가 발생하며, 연관관계를 위해 추가적인 update문이 나가기 때문에 overhead가 존재하기도 한다.</p>
<p data-ke-size="size16">&nbsp;Consumption과 Coordinate 사이에 양방향 매핑을 사용하면 편리하겠지만 최대한 최적화와 학습을 생각해서 다대일 매핑만 사용한다고 치자.&nbsp;</p>
<blockquote data-ke-style="style2">그리고 양방향을 사용하는 것 자체가 entity 사이에 너무나도 명확한 dependency가 생겨버리기 때문에 별로 좋은 방식이 아닌 것 같다는 생각이 계속 든다.</blockquote>
<p data-ke-size="size16">&nbsp;</p>
<pre id="code_1694012486745" class="sql" data-ke-language="sql" data-ke-type="codeblock"><code>SELECT * FROM
	(SELECT * FROM consumption c ORDER BY c.consumption_id ASC LIMIT 1 OFFSET 0) cresult
	LEFT JOIN coordinate co ON cresult.consumption_id = co.consumption_id;</code></pre>
<p data-ke-size="size16">&nbsp;사용자가 쓴 킥보드 사용량과 이동 경로를 한 번에 불러오고 싶다면, DB에서는 위와 같은 쿼리를 날리면 된다.</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">&nbsp;그런데 <b>JPQL에서 이를 사용할 수 없다</b>. JPQL에서는 FROM 절에 subquery를 넣을 수 없기 때문이다.</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">&nbsp;</p>
<h2 data-ke-size="size26">문제 해결 방안</h2>
<p data-ke-size="size16">&nbsp;문제를 해결할 수 있는 방법은 크게 3가지가 있을 것 같다.</p>
<ol style="list-style-type: decimal;" data-ke-list-type="decimal">
<li>어떻게든 join을 써서 풀어보기</li>
<li>query를 2번 날리던가</li>
<li>native query를 사용하던가.</li>
</ol>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">&nbsp;그러나 각각의 방식에는 마음에 들지 않는 것이 하나씩 있었다.</p>
<ol style="list-style-type: decimal;" data-ke-list-type="decimal">
<li>join으로 풀어보기 - paging을 해야 한다. join 결과에 paging을 걸면 coordinate에 paging이 걸린다. 아무리 생각해도 join으로 풀 수가 없었다.</li>
<li>query 2번 날리기 - 1번은 paging을 써서 consumption을 가져오고, 다음 번에 첫 번째 query 결과를 사용하는 방법.</li>
<li>native query 사용하기 - 그러면 추가 DTO도 사용해 Object[] 결과값을 매핑도 해야 하고(관리의 overhead), query가 DB에 종속되는 단점이 있었다.</li>
</ol>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">그래서 2번째 방식인, query 2번 날리는 방식을 채택했다.</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">&nbsp;</p>
<h2 data-ke-size="size26">해결 방안 - query 2번 날리기</h2>
<pre class="java" data-ke-language="java" data-ke-type="codeblock"><code>public List&lt;Consumption&gt; findConsumptionsWithPaging(PageDto pageDto){
    String consumptionPagingQuery = "SELECT c FROM Consumption c ORDER BY c.id DESC";
    return em.createQuery(consumptionPagingQuery, Consumption.class)
                .setFirstResult((pageDto.getPageNum() - 1) * pageDto.getPageSize())
                .setMaxResults(pageDto.getPageSize())
                .getResultList();
}</code></pre>
<p data-ke-size="size16">&nbsp;consumption을 paging을 적용한 결과로 받아온다. 받아온 결과를 consumptions라고 하자.</p>
<p data-ke-size="size16">&nbsp;</p>
<pre class="java" data-ke-language="java" data-ke-type="codeblock"><code>public List&lt;Coordinate&gt; findCoordinatesByConsumptions(List&lt;Consumption&gt; consumptions){
    String coordinatesByConsumptionsQuery = "SELECT co FROM Coordinate co WHERE co.consumption IN :consumptions";
    return em.createQuery(coordinatesByConsumptionsQuery, Coordinate.class)
                .setParameter("consumptions", consumptions)
                .getResultList();
}</code></pre>
<p data-ke-size="size16">&nbsp;그 consumptions의 IN 문을 사용해서 가져온다.</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">&nbsp;이렇게 짜는 것은 효율적이지는 않지만... 확장성과 성능은 어느 정도 반비례에 있기 때문에... 성능은 조금 떨어지지만 이게 맞는 것 같다.</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">&nbsp;</p>
<h2 data-ke-size="size26">후속 의문점 - 벤치마크</h2>
<p data-ke-size="size16">&nbsp;지금 예시로 든 것은 작은 query지만, 만약 더 복잡한 query라면 어떻게 될까. 작은 query 여러 개를 날리는 것이 좋을까, 아니면 큰 native query 하나를 날리는 것이 좋을까?</p>
<p data-ke-size="size16">&nbsp;</p>
<h4 data-ke-size="size20">lock contention</h4>
<p data-ke-size="size16">&nbsp;소마 멘토님께 여쭤봤을 때는, 큰 query 하나를 처리할 때는 그것을 처리하는 동안 DB에 write lock이 걸리기 때문에 다른 client들이 DB에 접근하지 못한다고 했다. 반면 작은 query 여러 개를 쓰면 (짧은) DB 호출을 여러 번 하게 되는 것이므로 client들의 지연 시간이라는 입장에서 보았을 때는 비슷하다는 말을 해 주셨다.</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">&nbsp;이 말에는 조금 의문이 생기는데, select문은 수정하지 않으니까 shared lock이 걸릴 것 같다. 그래서 여러 client가 동시에 동일한 table에 접근하는 경우에는 딱히 문제가 안 될 것 같긴 하다. 문제는 exclusive lock인 경우인데... 이 경우에는 설명하신 내용이 맞는 것 같다. 그리고 read와 write가 이어져서 발생하는 read-write 문제 (OS에서 살펴본)가 발생하는 경우도 있으므로 이 경우도 복잡해진다. 이는 DB의 구현에 달려있기 때문에 lock contention까지 신경쓴다면 직접 여러 client가 같은 DB에 접속하는 multi thread 상황을 만들고 테스트해봐야 할 것 같다.</p>
<p data-ke-size="size16">&nbsp;</p>
<h4 data-ke-size="size20">monster query vs multiple small queires</h4>
<p data-ke-size="size16">&nbsp;큰 쿼리 하나를 여러 개의 작은 쿼리로 나누는 것을 <b>join decomposition</b>이라고 한다. 이렇게 사용할 경우 일방적인 손해 같지만 몇 가지 이점도 있다고 한다. (High Performance MySQL 책)&nbsp;</p>
<ul style="list-style-type: disc;" data-ke-list-type="disc">
<li>caching이 효율적이게 된다.</li>
<li>lock contention이 줄어든다.</li>
<li>optimizer의 최적화 정도는 join보다 in이 더 높기 때문에 더 빠를 수 있다.</li>
<li>join의 경우 중복된 row들을 계속 탐색하는데, 이를 줄일 수 있다.</li>
<li>중복된 row 탐색을 줄일 수 있기 때문에 memory 사용량도 줄일 수 있다.</li>
</ul>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">&nbsp;반면, DB와 application 사이에 데이터를 전송하는 overhead도 존재한다. 만약 DB가 별도의 서버로 분리되어 있는 경우에는 network overhead도 발생할 것이다.</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">&nbsp;많은 글들을 찾아봤을 때, 절대적인 시간 하나로만 따져봤을 때는 큰 쿼리 하나만 사용하는 것이 훨씬 더 낫다고 한다.</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">&nbsp;</p>
<h3 data-ke-size="size23">벤치마크</h3>
<p data-ke-size="size16">&nbsp;그래서, 벤치마크용 툴을 사용하는 것도 아니고 너무 큰 query를 사용하는 것도 아니지만, 나름대로 어떻게 코드를 짜서 벤치마크 해 봤다.</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">&nbsp;</p>
<h2 data-ke-size="size26">결론</h2>
<p data-ke-size="size16">&nbsp;paging 하려고 consumption에 paging subquery를 걸어놔야 하는데, JPQL은 FROM 절에 subquery가 안걸려서 query 2번 날렸다.</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">&nbsp;그리고 대용량의 데이터를 다룰 경우 결과가 바뀌는 요인들이 많으니 상황에 맞게 사용해야 한다. 가능하면 벤치마킹을 한 후 더 좋은 것으로 쓰면 될 것 같다.</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">&nbsp;</p>